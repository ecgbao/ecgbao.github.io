<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="跳跳魔王的技术博客" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="跳跳魔王的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="跳跳魔王的技术博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跳跳魔王的技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>跳跳魔王的技术博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跳跳魔王的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">科技改变生活</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/21/链表第11课（合并两个有序链表）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/链表第11课（合并两个有序链表）/" itemprop="url">链表 | 第11课（合并两个有序链表）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T08:54:29+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>变形一个 SortedMerge() 函数，带有两个链表参数, 每个链表都是按照升序排列, 然后把这两个链表合并成一个升序的链表。 SortedMerge() 应该返回一个全新的链表。新链表应该把两个链表的结点拼接起来。</p>
<p>例如第一个链表是 5-&gt;10-&gt;15 第二个链表是 2-&gt;3-&gt;20, 然后 SortedMerge() 应该返回 2-&gt;3-&gt;5-&gt;10-&gt;15-&gt;20.</p>
<p>有很多情况需要处理: ‘a’ 或者 ‘b’ 可能为空, 处理 ‘a’ 或 ‘b’ 过程中可能首先跑完某个, 最后的问题是开始结果是空, 然后通过‘a’ 和 ‘b’ 把它建立起来。</p>
<h4 id="方法-1-使用仿制结点"><a href="#方法-1-使用仿制结点" class="headerlink" title="方法 1 (使用仿制结点)"></a>方法 1 (使用仿制结点)</h4><p>这里的策略是使用一个临时的仿制结点，作为结果链表的开始。Tail 指针总是表示结果链表的最后一个结点, 所以添加新结点很容易。<br>在结果链表是空的时候，仿制结点会给尾部指针一些指向作为初始化。仿制结点是有效的, 因为它只是临时的, 而且它在栈内分配。循环进行, 从 ‘a’ 或者 ‘b’ 移除一个结点, 然后添加到尾部。当完事后，结果就保存在 dummy.next.</p>
<pre><code>/* C/C++ program to merge two sorted linked lists */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

/* pull off the front node of the source and put it in dest */
void MoveNode(struct Node** destRef, struct Node** sourceRef);

/* Takes two lists sorted in increasing order, and splices
   their nodes together to make one big sorted list which
   is returned.  */
struct Node* SortedMerge(struct Node* a, struct Node* b)
{
    /* a dummy first node to hang the result on */
    struct Node dummy;

    /* tail points to the last result node  */
    struct Node* tail = &amp;dummy;

    /* so tail-&gt;next is the place to add new nodes
      to the result. */
    dummy.next = NULL;
    while (1)
    {
        if (a == NULL)
        {
            /* if either list runs out, use the
               other list */
            tail-&gt;next = b;
            break;
        }
        else if (b == NULL)
        {
            tail-&gt;next = a;
            break;
        }
        if (a-&gt;data &lt;= b-&gt;data)
            MoveNode(&amp;(tail-&gt;next), &amp;a);
        else
            MoveNode(&amp;(tail-&gt;next), &amp;b);

        tail = tail-&gt;next;
    }
    return(dummy.next);
}

/* UTILITY FUNCTIONS */
/* MoveNode() function takes the node from the front of the
   source, and move it to the front of the dest.
   It is an error to call this with the source list empty.

   Before calling MoveNode():
   source == {1, 2, 3}
   dest == {1, 2, 3}

   Affter calling MoveNode():
   source == {2, 3}
   dest == {1, 1, 2, 3} */
void MoveNode(struct Node** destRef, struct Node** sourceRef)
{
    /* the front source node  */
    struct Node* newNode = *sourceRef;
    assert(newNode != NULL);

    /* Advance the source pointer */
    *sourceRef = newNode-&gt;next;

    /* Link the old dest off the new node */
    newNode-&gt;next = *destRef;

    /* Move dest to point to the new node */
    *destRef = newNode;
}


/* Function to insert a node at the beginging of the
   linked list */
void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
        (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print nodes in a given linked list */
void printList(struct Node *node)
{
    while (node!=NULL)
    {
        printf(&quot;%d &quot;, node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct Node* res = NULL;
    struct Node* a = NULL;
    struct Node* b = NULL;

    /* Let us create two sorted linked lists to test
      the functions
       Created lists, a: 5-&gt;10-&gt;15,  b: 2-&gt;3-&gt;20 */
    push(&amp;a, 15);
    push(&amp;a, 10);
    push(&amp;a, 5);

    push(&amp;b, 20);
    push(&amp;b, 3);
    push(&amp;b, 2);

    /* Remove duplicates from linked list */
    res = SortedMerge(a, b);

    printf(&quot;Merged Linked List is: \n&quot;);
    printList(res);

    return 0;
}
</code></pre><p>#<br>    输出 :</p>
<pre><code>Merged Linked List is: 
2 3 5 10 15 20 
</code></pre><h4 id="方法-2-使用本地引用"><a href="#方法-2-使用本地引用" class="headerlink" title="方法 2 (使用本地引用)"></a>方法 2 (使用本地引用)</h4><p>这个方案在结构上跟上面的很相似, 但是它没有使用仿制结点。替代方案是, 它维护了一个结构体 node** 指针, lastPtrRef 这指针总是指向结果链表的最后一个结点。这个方式解决了仿制结点解决的问题 — 处理了结果链表为空的情况。</p>
<pre><code>struct Node* SortedMerge(struct Node* a, struct Node* b) 
{
  struct Node* result = NULL;

  /* point to the last result pointer */
  struct Node** lastPtrRef = &amp;result; 

  while(1) 
  {
    if (a == NULL) 
    {
      *lastPtrRef = b;
       break;
    }
    else if (b==NULL) 
    {
       *lastPtrRef = a;
       break;
    }
    if(a-&gt;data &lt;= b-&gt;data) 
    {
      MoveNode(lastPtrRef, &amp;a);
    }
    else
    {
      MoveNode(lastPtrRef, &amp;b);
    }

    /* tricky: advance to point to the next &quot;.next&quot; field */
    lastPtrRef = &amp;((*lastPtrRef)-&gt;next); 
  }
  return(result);
}
</code></pre><h4 id="方法-3-使用递归"><a href="#方法-3-使用递归" class="headerlink" title="方法 3 (使用递归)"></a>方法 3 (使用递归)</h4><p>递归的代码比迭代代码更加清晰。你可能不太想使用递归方法，因为它会随着链表的长度成比例的使用栈空间。</p>
<pre><code>struct Node* SortedMerge(struct Node* a, struct Node* b) 
{
  struct Node* result = NULL;

  /* Base cases */
  if (a == NULL) 
     return(b);
  else if (b==NULL) 
     return(a);

  /* Pick either a or b, and recur */
  if (a-&gt;data &lt;= b-&gt;data) 
  {
     result = a;
     result-&gt;next = SortedMerge(a-&gt;next, b);
  }
  else
  {
     result = b;
     result-&gt;next = SortedMerge(a, b-&gt;next);
  }
  return(result);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/链表第10课（查找链表中的循环）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/链表第10课（查找链表中的循环）/" itemprop="url">链表 | 第10课（查找链表中的循环）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T15:29:06+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>指定一个链表, 判断其中是否存在循环。下面的图表表示链表中存在一个循环。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/2009/04/Linked-List-Loop.gif" alt=""></p>
<p>下面用两种不同方法来实现</p>
<h4 id="使用哈希"><a href="#使用哈希" class="headerlink" title="使用哈希:"></a>使用哈希:</h4><p>顺序遍历链表，把结点地址放在一个哈希表中。任何时候, 如果地址为 NULL 表示链表到头，就返回 false, 如果当前结点的后继结点地址跟哈希表里的某个地址相同就返回 true.</p>
<pre><code>// C++ program to detect loop in a linked list
#include&lt;bits/stdc++.h&gt;
using namespace std;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node = new Node;

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

// Returns true if there is a loop in linked list
// else returns false.
bool detectLoop(struct Node *h)
{
    unordered_set&lt;Node *&gt; s;
    while (h != NULL)
    {
        // If we have already has this node
        // in hashmap it means their is a cycle
        // (Because you we encountering the
        // node second time).
        if (s.find(h) != s.end())
            return true;

        // If we are seeing the node for
        // the first time, insert it in hash
        s.insert(h);

        h = h-&gt;next;
    }

    return false;
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;

    push(&amp;head, 20);
    push(&amp;head, 4);
    push(&amp;head, 15);
    push(&amp;head, 10);

    /* Create a loop for testing */
    head-&gt;next-&gt;next-&gt;next-&gt;next = head;

    if (detectLoop(head))
        cout &lt;&lt; &quot;Loop found&quot;;
    else
        cout &lt;&lt; &quot;No Loop&quot;;

    return 0;
}

输出 :
Loop Found
</code></pre><h4 id="标记访问过的结点"><a href="#标记访问过的结点" class="headerlink" title="标记访问过的结点:"></a>标记访问过的结点:</h4><p>这个方案需要修改链表的数据结构。每个结点有个 visited 标记。遍历整个链表，标记所有访问过的结点。如果你再次看见访问过的结点，就表明存在一个循环。这个方案的时间复杂度是 O(n), 但是每个结点需要额外的信息。<br>这个方案可以修改成不修改链表的数据结构, 然后使用哈希来实现。仅仅是把访问过的结点地址放进哈希表，如果发现后面访问的地址在哈希表里存在，就表示有循环存在。</p>
<h4 id="循环查找算法"><a href="#循环查找算法" class="headerlink" title="循环查找算法:"></a>循环查找算法:</h4><p>这是个最快的方法。使用两个指针进行遍历。一个指针每次向前移动一步，另外一个指针移动两步。如果这两个指针在某个结点相遇，就表明存在一个循环。如果指针不相遇就表明链表不存在循环。</p>
<h4 id="循环查找算法的实现"><a href="#循环查找算法的实现" class="headerlink" title="循环查找算法的实现:"></a>循环查找算法的实现:</h4><pre><code>// C program to detect loop in a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
          (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

int detectloop(struct Node *list)
{
    struct Node  *slow_p = list, *fast_p = list;

    while (slow_p &amp;&amp; fast_p &amp;&amp; fast_p-&gt;next )
    {
        slow_p = slow_p-&gt;next;
        fast_p  = fast_p-&gt;next-&gt;next;
        if (slow_p == fast_p)
        {
           printf(&quot;Found Loop&quot;);
           return 1;
        }
    }
    return 0;
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;

    push(&amp;head, 20);
    push(&amp;head, 4);
    push(&amp;head, 15);
    push(&amp;head, 10);

    /* Create a loop for testing */
    head-&gt;next-&gt;next-&gt;next-&gt;next = head;
    detectloop(head);

    return 0;
}


输出:
Found loop
</code></pre><h5 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度: O(n)"></a>时间复杂度: O(n)</h5><h5 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度: O(1)"></a>空间复杂度: O(1)</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/链表第9课翻转链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/链表第9课翻转链表/" itemprop="url">链表 | 第9课（翻转链表）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T13:27:09+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给定一个链表的头结点指针, 目标是翻转这个链表。</p>
<p>例子:</p>
<pre><code>Input : Head of following linked list  
       1-&gt;2-&gt;3-&gt;4-&gt;NULL
Output : Linked list should be changed to,
       4-&gt;3-&gt;2-&gt;1-&gt;NULL

Input : Head of following linked list  
       1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output : Linked list should be changed to,
       5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL

Input : NULL
Output : NULL

Input  : 1-&gt;NULL
Output : 1-&gt;NULL
</code></pre><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><pre><code>利用3个指针，prev 为 NULL, curr 等于头结点，next 为 NULL.
遍历整个链表。在循环体内, 这样做。
// Before changing next of current,
// next node
next = curr-&gt;next

// This is where actual reversing happens
curr-&gt;next = prev

// Move prev and curr one step forward
prev = curr
curr = next
</code></pre><h4 id="循环第一步结束-i-e-在-next-curr-gt-next-之后"><a href="#循环第一步结束-i-e-在-next-curr-gt-next-之后" class="headerlink" title="循环第一步结束, i.e., 在 next = curr-&gt;next 之后"></a>循环第一步结束, i.e., 在 next = curr-&gt;next 之后</h4><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/reverse-list-iterative1-2.png" alt=""></p>
<h4 id="循环一次之后"><a href="#循环一次之后" class="headerlink" title="循环一次之后"></a>循环一次之后</h4><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/reverse-list-iterative2.png" alt=""></p>
<pre><code>// Iterative C program to reverse a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

/* Function to reverse the linked list */
static void reverse(struct Node** head_ref)
{
    struct Node* prev   = NULL;
    struct Node* current = *head_ref;
    struct Node* next = NULL;
    while (current != NULL)
    {
        next  = current-&gt;next;  
        current-&gt;next = prev;   
        prev = current;
        current = next;
    }
    *head_ref = prev;
}

/* Function to push a node */
void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);    

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print linked list */
void printList(struct Node *head)
{
    struct Node *temp = head;
    while(temp != NULL)
    {
        printf(&quot;%d  &quot;, temp-&gt;data);    
        temp = temp-&gt;next;  
    }
}    

/* Driver program to test above function*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;

     push(&amp;head, 20);
     push(&amp;head, 4);
     push(&amp;head, 15); 
     push(&amp;head, 85);      

     printf(&quot;Given linked list\n&quot;);
     printList(head);    
     reverse(&amp;head);                      
     printf(&quot;\nReversed Linked list \n&quot;);
     printList(head);    
     getchar();
}
</code></pre><p>###<br>    所给链表<br>    85 15 4 20<br>    翻转后的链表<br>    20 4 15 85 </p>
<h5 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度: O(n)"></a>时间复杂度: O(n)</h5><h5 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度: O(1)"></a>空间复杂度: O(1)</h5><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法:"></a>递归方法:</h4><pre><code>1) 把链表划分为2部分 - 第一个结点和剩下的结点
2) 对剩下的链表调用翻转方法.
3) 把剩下的链表链接到第一个结点.
4) 固定头指针
</code></pre><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/2009/07/Linked-List-Rverse.gif" alt=""></p>
<pre><code>void recursiveReverse(struct Node** head_ref)
{
    struct Node* first;
    struct Node* rest;

    /* empty list */
    if (*head_ref == NULL)
       return;   

    /* suppose first = {1, 2, 3}, rest = {2, 3} */
    first = *head_ref;  
    rest  = first-&gt;next;

    /* List has only one node */
    if (rest == NULL)
       return;   

    /* reverse the rest list and put the first element at the end */
    recursiveReverse(&amp;rest);
    first-&gt;next-&gt;next  = first;  

    /* tricky step -- see the diagram */
    first-&gt;next  = NULL;          

    /* fix the head pointer */
    *head_ref = rest;              
}
</code></pre><h5 id="时间复杂度-O-n-1"><a href="#时间复杂度-O-n-1" class="headerlink" title="时间复杂度: O(n)"></a>时间复杂度: O(n)</h5><h5 id="空间复杂度-O-1-1"><a href="#空间复杂度-O-1-1" class="headerlink" title="空间复杂度: O(1)"></a>空间复杂度: O(1)</h5><h4 id="一个更简单的方法"><a href="#一个更简单的方法" class="headerlink" title="一个更简单的方法"></a>一个更简单的方法</h4><p>下面的方法用 C++ 实现。</p>
<pre><code>// A simple and tail recursive C++ program to reverse
// a linked list
#include&lt;bits/stdc++.h&gt;
using namespace std;

struct Node
{
    int data;
    struct Node *next;
};

void reverseUtil(Node *curr, Node *prev, Node **head);

// This function mainly calls reverseUtil()
// with prev as NULL
void reverse(Node **head)
{
    if (!head)
        return;
    reverseUtil(*head, NULL, head);
}

// A simple and tail recursive function to reverse
// a linked list.  prev is passed as NULL initially.
void reverseUtil(Node *curr, Node *prev, Node **head)
{
    /* If last node mark it head*/
    if (!curr-&gt;next)
    {
        *head = curr;

        /* Update next to prev node */
        curr-&gt;next = prev;
        return;
    }

    /* Save curr-&gt;next node for recursive call */
    node *next = curr-&gt;next;

    /* and update next ..*/
    curr-&gt;next = prev;

    reverseUtil(next, curr, head);
}

// A utility function to create a new node
Node *newNode(int key)
{
    Node *temp = new Node;
    temp-&gt;data = key;
    temp-&gt;next = NULL;
    return temp;
}

// A utility function to print a linked list
void printlist(Node *head)
{
    while(head != NULL)
    {
        cout &lt;&lt; head-&gt;data &lt;&lt; &quot; &quot;;
        head = head-&gt;next;
    }
    cout &lt;&lt; endl;
}

// Driver program to test above functions
int main()
{
    Node *head1 = newNode(1);
    head1-&gt;next = newNode(2);
    head1-&gt;next-&gt;next = newNode(3);
    head1-&gt;next-&gt;next-&gt;next = newNode(4);
    head1-&gt;next-&gt;next-&gt;next-&gt;next = newNode(5);
    head1-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = newNode(6);
    head1-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = newNode(7);
    head1-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = newNode(8);
    cout &lt;&lt; &quot;Given linked list\n&quot;;
    printlist(head1);
    reverse(&amp;head1);
    cout &lt;&lt; &quot;\nReversed linked list\n&quot;;
    printlist(head1);
    return 0;
}
</code></pre><p>###</p>
<pre><code>Output:
Given linked list
1 2 3 4 5 6 7 8

Reversed linked list
8 7 6 5 4 3 2 1
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/链表第8课输出链表的中间结点值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/链表第8课输出链表的中间结点值/" itemprop="url">链表 | 第8课（输出链表的中间结点值）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T13:07:07+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给定一个单链表, 查找中间结点。比如, 如果所给的链表是<strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>就输出<strong>3</strong>.</p>
<p>如果有偶数个结点, 那就有两个中间的结点, 我们需要打印第二个结点元素。例如, 如果所给的链表是<strong>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</strong>那么就输出<strong>4</strong> </p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1:"></a>方法 1:</h4><p>遍历整个链表并计算结点的个数。然后遍历结点到 <strong><em>count/2</em></strong> 然后返回此处的结点。</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2:"></a>方法 2:</h4><p>使用两个指针遍历链表。第一个指针每次移动一个位置，第二个指针每次移动两个位置。当最快的指针到达最后的时候，最慢的指针正好到达链表的中间位置。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

/* Function to get the middle of the linked list*/
void printMiddle(struct Node *head)
{
    struct Node *slow_ptr = head;
    struct Node *fast_ptr = head;

    if (head!=NULL)
    {
        while (fast_ptr != NULL &amp;&amp; fast_ptr-&gt;next != NULL)
        {
            fast_ptr = fast_ptr-&gt;next-&gt;next;
            slow_ptr = slow_ptr-&gt;next;
        }
        printf(&quot;The middle element is [%d]\n\n&quot;, slow_ptr-&gt;data);
    }
}

void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
        (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

// A utility function to print a given linked list
void printList(struct Node *ptr)
{
    while (ptr != NULL)
    {
        printf(&quot;%d-&gt;&quot;, ptr-&gt;data);
        ptr = ptr-&gt;next;
    }
    printf(&quot;NULL\n&quot;);
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;
    int i;

    for (i=5; i&gt;0; i--)
    {
        push(&amp;head, i);
        printList(head);
        printMiddle(head);
    }

    return 0;
}
</code></pre><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><pre><code>Output:
5-&gt;NULL
The middle element is [5]

4-&gt;5-&gt;NULL
The middle element is [5]

3-&gt;4-&gt;5-&gt;NULL
The middle element is [4]

2-&gt;3-&gt;4-&gt;5-&gt;NULL
The middle element is [4]

1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
The middle element is [3]
</code></pre><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3:"></a>方法 3:</h4><p>初始化一个中间元素等于头结点，然后初始化一个计数器为 0. 从头遍历链表, 遍历的时候增加计数器，当计时器是奇数时，修改<strong>mid</strong>为<strong>mid-&gt;next</strong>。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Function to get the middle of the linked list*/
void printMiddle(struct node *head)
{
    int count = 0;
    struct node *mid = head;

    while (head != NULL)
    {
        /* update mid, when &apos;count&apos; is odd number */
        if (count &amp; 1)
            mid = mid-&gt;next;

        ++count;
        head = head-&gt;next;
    }

    /* if empty list is provided */
    if (mid != NULL)
        printf(&quot;The middle element is [%d]\n\n&quot;, mid-&gt;data);
}


void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

// A utility function to print a given linked list
void printList(struct node *ptr)
{
    while (ptr != NULL)
    {
        printf(&quot;%d-&gt;&quot;, ptr-&gt;data);
        ptr = ptr-&gt;next;
    }
    printf(&quot;NULL\n&quot;);
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;
    int i;

    for (i=5; i&gt;0; i--)
    {
        push(&amp;head, i);
        printList(head);
        printMiddle(head);
    }

    return 0;
}
</code></pre><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><pre><code>Output:

5-&gt;NULL
The middle element is [5]

4-&gt;5-&gt;NULL
The middle element is [5]

3-&gt;4-&gt;5-&gt;NULL
The middle element is [4]

2-&gt;3-&gt;4-&gt;5-&gt;NULL
The middle element is [4]

1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
The middle element is [3]
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/链表第7课获取第N个结点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/链表第7课获取第N个结点/" itemprop="url">链表 | 第7课（获取第N个结点）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T12:58:23+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>编写一个函数 <strong>GetNth()</strong>，输入参数是一个链表和一个索引值，然后这个索引位置的结点值。</p>
<p>例如:</p>
<pre><code>Input:  1-&gt;10-&gt;30-&gt;14,  index = 2
Output: 30  
The node at index 2 is 30
</code></pre><h4 id="算法"><a href="#算法" class="headerlink" title="算法:"></a>算法:</h4><pre><code>1. 初始化 count = 0
2. 循环链表
     a. 如果 count 等于输入的索引，就返回当前结点
         node
     b. 递增 count
     c. 当前指针后移
</code></pre><h4 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h4><pre><code>// C program to find n&apos;th node in linked list
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

/* Given a reference (pointer to pointer) to the head
    of a list and an int, push a new node on the front
    of the list. */
void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Takes head pointer of the linked list and index
    as arguments and return data at index*/
int GetNth(struct Node* head, int index)
{
    struct Node* current = head;
    int count = 0; /* the index of the node we&apos;re currently
                  looking at */
    while (current != NULL)
    {
       if (count == index)
          return(current-&gt;data);
       count++;
       current = current-&gt;next;
    }

    /* if we get to this line, the caller was asking
       for a non-existent element so we assert fail */
    assert(0);              
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;

    /* Use push() to construct below list
     1-&gt;12-&gt;1-&gt;4-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 4);
    push(&amp;head, 1);
    push(&amp;head, 12);
    push(&amp;head, 1);  

    /* Check the count function */
    printf(&quot;Element at index 3 is %d&quot;, GetNth(head, 3));  
    getchar();
}

Output:
Element at index 3 is 4
</code></pre><h4 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度: O(n)"></a>时间复杂度: O(n)</h4><h4 id="方法-2-使用递归"><a href="#方法-2-使用递归" class="headerlink" title="方法 2- 使用递归"></a>方法 2- 使用递归</h4><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法:"></a>算法:</h4><pre><code>getnth(node,n)
1. 初始化 count = 1
2. if count == n
     return node-&gt;data
3. else
    return getnth(node-&gt;next,n-1)
</code></pre><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现:"></a>实现:</h4><pre><code>// C program to find n&apos;th node in linked list 
// using recursion
#include &lt;bits/stdc++.h&gt;
using namespace std;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

/*  Given a reference (pointer to pointer) to 
    the head of a list and an int, push a 
    new node on the front of the list. */
void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* put in the data */
    new_node-&gt;data = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref) = new_node;
}

/* Takes head pointer of the linked list and index
    as arguments and return data at index*/
int GetNth(struct Node *head,int n)
{
    int count = 1;

    //if count equal too n return node-&gt;data
    if(count == n)
    return head-&gt;data;

    //recursively decrease n and increase 
    // head to next pointer 
    return GetNth(head-&gt;next, n-1); 
}

/* Drier program to test above function*/
int main()
{
     /* Start with the empty list */
    struct Node* head = NULL;

    /* Use push() to construct below list
     1-&gt;12-&gt;1-&gt;4-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 4);
    push(&amp;head, 1);
    push(&amp;head, 12);
    push(&amp;head, 1);  

    /* Check the count function */
    printf(&quot;Element at index 3 is %d&quot;, GetNth(head, 3));  
    getchar();
}

Output:
Element at index 3 is 1
</code></pre><h4 id="时间复杂度-O-n-1"><a href="#时间复杂度-O-n-1" class="headerlink" title="时间复杂度: O(n)"></a>时间复杂度: O(n)</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/链表第6课（交换结点而不交换数据）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/链表第6课（交换结点而不交换数据）/" itemprop="url">链表 | 第6课（交换结点而不交换数据）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T16:50:18+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>提供一个链表和两个key, 交换这两个key的结点。结点可以通过修改连接进行交换。而交换数据通常代价会很大, 因为数据可能含有很多内容。</p>
<p>假设链表里的所有key都是不同的。</p>
<p>例子:</p>
<pre><code>Input:  10-&gt;15-&gt;12-&gt;13-&gt;20-&gt;14,  x = 12, y = 20
Output: 10-&gt;15-&gt;20-&gt;13-&gt;12-&gt;14

Input:  10-&gt;15-&gt;12-&gt;13-&gt;20-&gt;14,  x = 10, y = 20
Output: 20-&gt;15-&gt;12-&gt;13-&gt;10-&gt;14

Input:  10-&gt;15-&gt;12-&gt;13-&gt;20-&gt;14,  x = 12, y = 13
Output: 10-&gt;15-&gt;13-&gt;12-&gt;20-&gt;14
</code></pre><p>这个看起来很简单, 但是下面的场景处理起来很有趣。</p>
<ol>
<li>x 和 y 可能相邻也可能不是。</li>
<li>x 和 y 可能是头结点。</li>
<li>x 和 y 可能是尾结点。</li>
<li>x 和/或 y 可能不在链表里。</li>
</ol>
<p>如何写代码来处理上述所有的情况？</p>
<p>想法是，先在链表里搜索 x 和 y. 如果有一个没有找到, 就返回。在搜索 x 和 y 的时候, 跟踪当前和前驱指针。首先改变前驱指针的后继, 然后修改当前指针的后继。下面是 C 语言实现的方法。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* 链表结点 */
struct Node
{
    int data;
    struct Node *next;
};

void swapNodes(struct Node **head_ref, int x, int y)
{
   // 如果x 和 y 相等，直接返回
   if (x == y) return;

   // 搜索 x (跟踪 prevX 和 CurrX
   struct Node *prevX = NULL, *currX = *head_ref;
   while (currX &amp;&amp; currX-&gt;data != x)
   {
       prevX = currX;
       currX = currX-&gt;next;
   }

   // 搜索 y (跟踪 prevY 和 CurrY
   struct Node *prevY = NULL, *currY = *head_ref;
   while (currY &amp;&amp; currY-&gt;data != y)
   {
       prevY = currY;
       currY = currY-&gt;next;
   }

   // 如果 x 或者 y 没有找到, 返回
   if (currX == NULL || currY == NULL)
       return;

   // 如果 x 不是头结点
   if (prevX != NULL)
       prevX-&gt;next = currY;
   else // 否则 y 变成新的头结点
       *head_ref = currY;  

   // 如果 y 不是头结点
   if (prevY != NULL)
       prevY-&gt;next = currX;
   else  // 否则 x 变成新的头结点
       *head_ref = currX;

   // 交换后继指针
   struct Node *temp = currY-&gt;next;
   currY-&gt;next = currX-&gt;next;
   currX-&gt;next  = temp;
}

void push(struct Node** head_ref, int new_data)
{
    /* 分配结点 */
    struct Node* new_node =
        (struct Node*) malloc(sizeof(struct Node));

    /* 指定数据  */
    new_node-&gt;data  = new_data;

    /* 把新结点和老的链表相连 */
    new_node-&gt;next = (*head_ref);

    /* 新结点变成头结点 */
    (*head_ref)    = new_node;
}

/* 打印链表结点 */
void printList(struct Node *node)
{
    while(node != NULL)
    {
        printf(&quot;%d &quot;, node-&gt;data);
        node = node-&gt;next;
    }
}

/* 测试函数 */
int main()
{
    struct Node *start = NULL;

    /* 构造的链表:
     1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 */
    push(&amp;start, 7);
    push(&amp;start, 6);
    push(&amp;start, 5);
    push(&amp;start, 4);
    push(&amp;start, 3);
    push(&amp;start, 2);
    push(&amp;start, 1);

    printf(&quot;\n Linked list before calling swapNodes() &quot;);
    printList(start);

    swapNodes(&amp;start, 4, 3);

    printf(&quot;\n Linked list after calling swapNodes() &quot;);
    printList(start);

    return 0;
}


输出:
 Linked list before calling swapNodes() 1 2 3 4 5 6 7
 Linked list after calling swapNodes() 1 2 4 3 5 6 7
</code></pre><blockquote>
<p><strong><em>优化:</em></strong> 上面的代码可以优化，x 和 y 单独遍历。两个循环看起来比较简单。</p>
</blockquote>
<h4 id="更简单的方法"><a href="#更简单的方法" class="headerlink" title="更简单的方法"></a>更简单的方法</h4><pre><code>#include &lt;iostream&gt;

using namespace std;

// 结点类
class Node {

public:
    int data;
    class Node* next;

    // 构造器
    Node(int val, Node* next)
        : data(val), next(next)
    {
    }

    // 打印链表
    void printList()
    {

        Node* node = this;

        while (node != NULL) {

            cout &lt;&lt; node-&gt;data;
            node = node-&gt;next;
        }

        cout &lt;&lt; endl;
    }
};


void push(Node** head_ref, int new_data)
{

    // 分配结点
    (*head_ref) = new Node(new_data, *head_ref);
}

void swap(Node*&amp; a, Node*&amp; b)
{

    Node* temp = a;
    a = b;
    b = temp;
}

void swapNodes(Node** head_ref, int x, int y)
{

    // 如果 x 和 y 相等，返回
    if (x == y)
        return;

    Node **a = NULL, **b = NULL;

    // 在链表里搜索x 和 y
    // 然后保存它们的指针为 a 和 b
    while (*head_ref) {

        if ((*head_ref)-&gt;data == x) {
            a = head_ref;
        }

        else if ((*head_ref)-&gt;data == y) {
            b = head_ref;
        }

        head_ref = &amp;((*head_ref)-&gt;next);
    }

    // 如果发现 a 和 b
    // 交换当前指针以及它们的后继指针
    if (a &amp;&amp; b) {

        swap(*a, *b);
        swap(((*a)-&gt;next), ((*b)-&gt;next));
    }
}

int main()
{

    Node* start = NULL;

    // 构造链表:
    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7
    push(&amp;start, 7);
    push(&amp;start, 6);
    push(&amp;start, 5);
    push(&amp;start, 4);
    push(&amp;start, 3);
    push(&amp;start, 2);
    push(&amp;start, 1);

    cout &lt;&lt; &quot;Linked list before calling swapNodes() &quot;;
    start-&gt;printList();

    swapNodes(&amp;start, 6, 3);

    cout &lt;&lt; &quot;Linked list after calling swapNodes() &quot;;
    start-&gt;printList();
}

输出:

 Linked list before calling swapNodes() 1 2 3 4 5 6 7
 Linked list after calling swapNodes() 1 2 6 4 5 3 7
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/链表第5课（查找元素）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/链表第5课（查找元素）/" itemprop="url">链表 | 第5课（查找元素）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T15:48:16+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写一个 C 函数，在指定的单链表中查找一个指定的 key ‘x’. 如果 x 存在返回 true 否则返回 false.</p>
<pre><code>bool search(Node *head, int x) 
</code></pre><p>例如, 如果 key 是 15 ，链表是 14-&gt;21-&gt;11-&gt;30-&gt;10, 那么函数会返回 false. 如果 key 是 14, 函数就返回 true.</p>
<h3 id="迭代方案"><a href="#迭代方案" class="headerlink" title="迭代方案"></a>迭代方案</h3><pre><code>2) 初始一个结点指针, current = head.
3) 如果 current 不为 NULL 就继续循环
    a) current-&gt;key 等于要搜索的 key 返回 true.
    b) current = current-&gt;next
4) 返回 false 
</code></pre><p>下面是迭代方案的算法。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h

/* 链表结点 */
struct Node
{
    int key;
    struct Node* next;
};

/* 指向头结点的指针和一个整数, 在链表头部加入一个新结点. */
void push(struct Node** head_ref, int new_key)
{
    /* 分配结点 */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* 指定 key  */
    new_node-&gt;key  = new_key;

    /* 把新结点连接到老链表 */
    new_node-&gt;next = (*head_ref);

    /* 新结点变成头结点 */
    (*head_ref)    = new_node;
}

/* 判断 x 是否在链表里 */
bool search(struct Node* head, int x)
{
    struct Node* current = head;  // 初始 current
    while (current != NULL)
    {
        if (current-&gt;key == x)
            return true;
        current = current-&gt;next;
    }
    return false;
}

/* 测试程序*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;
    int x = 21;

    /* Use push() to construct below list
     14-&gt;21-&gt;11-&gt;30-&gt;10  */
    push(&amp;head, 10);
    push(&amp;head, 30);
    push(&amp;head, 11);
    push(&amp;head, 21);
    push(&amp;head, 14);

    search(head, 21)? printf(&quot;Yes&quot;) : printf(&quot;No&quot;);
    return 0;
}

输出:
Yes
</code></pre><h3 id="递归方案"><a href="#递归方案" class="headerlink" title="递归方案"></a>递归方案</h3><pre><code>bool search(head, x)
1) 如果头结点为 NULL, 返回 false.
2) 如果头结点的 key 等于 x, 返回 true;
2) 否则返回 search(head-&gt;next, x) 
</code></pre><p>下面是递归算法的实现.</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
/* Link list node */
struct Node
{
    int key;
    struct Node* next;
};

/* 指向头结点的指针和一个整数, 在链表头部加入一个新结点. */
void push(struct Node** head_ref, int new_key)
{
    /* 分配结点 */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* 指定 key  */
    new_node-&gt;key  = new_key;

    /* 把新结点连接到老链表 */
    new_node-&gt;next = (*head_ref);

    /* 新结点变成头结点 */
    (*head_ref)    = new_node;
}

/* 判断 x 是否在链表里 */
bool search(struct Node* head, int x)
{
    // 递归结束条件
    if (head == NULL)
        return false;

    // 如果 key 在头结点, 返回 true
    if (head-&gt;key == x)
        return true;

    // 递归剩下的列表
    return search(head-&gt;next, x);
}

/* 测试程序*/
int main()
{
    /* 开始空链表 */
    struct Node* head = NULL;
    int x = 21;

    /* 使用 push() 构造链表
     14-&gt;21-&gt;11-&gt;30-&gt;10  */
    push(&amp;head, 10);
    push(&amp;head, 30);
    push(&amp;head, 11);
    push(&amp;head, 21);
    push(&amp;head, 14);

    search(head, 21)? printf(&quot;Yes&quot;) : printf(&quot;No&quot;);
    return 0;
}

输出:
Yes
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/链表第4课（链表的长度）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/链表第4课（链表的长度）/" itemprop="url">链表 | 第4课（链表的长度）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T15:06:33+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要求写一个 C 函数计算指定单链表的结点数。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2015/03/Linkedlist_find_length.png" alt=""></p>
<p>例如, 链表<strong>1-&gt;3-&gt;1-&gt;2-&gt;1</strong>通过这个函数可以获取到 5 个结点。</p>
<h3 id="迭代方案"><a href="#迭代方案" class="headerlink" title="迭代方案"></a>迭代方案</h3><ol>
<li>初始化计数为 0 </li>
<li>初始化一个结点指针, <strong>current = head</strong>.</li>
<li><p>如果 current 不为 NULL 继续循环</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a) current = current -&gt; next</span><br><span class="line">b) count++;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>返回计数 </li>
</ol>
<p>下面是 C/C++ 实现的计数算法。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct Node
{
    int data;
    struct Node* next;
};

/* 指向头结点的指针和一个整数, 在链表的头部添加一个新结点. */
void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* 获取链表的结点数 */
int getCount(struct Node* head)
{
    int count = 0;  // 初始值
    struct Node* current = head;  // 当前结点
    while (current != NULL)
    {
        count++;
        current = current-&gt;next;
    }
    return count;
}

/* 测试函数*/
int main()
{
    /* 开始空链表 */
    struct Node* head = NULL;

    /* 使用 push() 构造链表
     1-&gt;2-&gt;1-&gt;3-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 1);
    push(&amp;head, 2);
    push(&amp;head, 1);

    /* 计数函数 */
    printf(&quot;count of nodes is %d&quot;, getCount(head));
    return 0;
}

输出:
count of nodes is 5
</code></pre><h3 id="递归方案"><a href="#递归方案" class="headerlink" title="递归方案"></a>递归方案</h3><h5 id="int-getCount-head"><a href="#int-getCount-head" class="headerlink" title="int getCount(head)"></a>int getCount(head)</h5><ol>
<li>如果头结点为 NULL, 返回 0.</li>
<li>否则返回 <code>return 1 + getCount(head-&gt;next)</code></li>
</ol>
<p>下面是 C/C++ 实现的递归算法。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* 链表结点 */
struct Node
{
    int data;
    struct Node* next;
};

/* 指向头结点的指针和一个整数, 在链表的头部添加一个新结点 */
void push(struct Node** head_ref, int new_data)
{
    /* 分配结点 */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* 指定数据  */
    new_node-&gt;data  = new_data;

    /* 指定新结点的后继为旧的头结点 */
    new_node-&gt;next = (*head_ref);

    /* 新结点成为头结点 */
    (*head_ref)    = new_node;
}

/* 计数函数*/
int getCount(struct Node* head)
{
    // 递归结束条件
    if (head == NULL)
        return 0;

    return 1 + getCount(head-&gt;next);
}

/* 测试函数*/
int main()
{
    /* 开始空链表 */
    struct Node* head = NULL;

    /* 使用 push() 构造链表
     1-&gt;2-&gt;1-&gt;3-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 1);
    push(&amp;head, 2);
    push(&amp;head, 1);

    /* 计数函数 */
    printf(&quot;count of nodes is %d&quot;, getCount(head));
    return 0;
}

输出:
count of nodes is 5
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/链表第2课（链表的插入）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/链表第2课（链表的插入）/" itemprop="url">链表| 第2课（链表的插入）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T13:58:06+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在先前的文章里，我们已经简单介绍了<a href="https://ecgbao.github.io/2018/03/09/%E9%93%BE%E8%A1%A8-%E7%AC%AC-1-%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89/" target="_blank" rel="noopener">链表</a>。我们也创建了一个带有3个结点的简单链表，然后讨论了一下如何遍历它们。</p>
<p><strong><em>这篇文章涉及到的所有程序均使用下面的结点表示链表。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 链表结点</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这篇文章里, 会讨论如何在链表里插入结点。一般来说，有3个方法来添加结点。</p>
<ol>
<li>在链表的首部。</li>
<li>在一个给定的结点之后。</li>
<li>在链表的尾部。</li>
</ol>
<h3 id="在首部添加一个结点-4步"><a href="#在首部添加一个结点-4步" class="headerlink" title="在首部添加一个结点: (4步)"></a>在首部添加一个结点: (4步)</h3><p>新结点要添加在给定链表的首部。新添加的结点成为新的头结点。例如, 如果给定的链表是<strong>10-&gt;15-&gt;20-&gt;25</strong> 我们要再首部添加一个<strong>5</strong>, 然后链表就会变成<strong>5-&gt;10-&gt;15-&gt;20-&gt;25</strong>. 我们使用一个函数<strong>push()</strong>来表示。 这个函数必须接收一个指向头指针的指针, 因为需要修改它指向新加的结点。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist_insert_at_start.png" alt=""></p>
<p>下面是在首部添加结点的4个步骤。</p>
<pre><code>/* 引用链表的头结点，指定一个整数, 然后在链表首部添加一个新的结点。*/
void push(struct Node** head_ref, int new_data)
{
    /* 1. 分配结点 */
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    /* 2. 指定数据  */
    new_node-&gt;data  = new_data;

    /* 3. 指定新结点的后继为 head_ref */
    new_node-&gt;next = (*head_ref);

    /* 4. 头部指向新结点 */
    (*head_ref)    = new_node;
}
</code></pre><p>这个函数的时间复杂度为 O(1)，因为它做的是连续数量的工作。</p>
<h3 id="在指定的结点后面添加结点-5-个步骤"><a href="#在指定的结点后面添加结点-5-个步骤" class="headerlink" title="在指定的结点后面添加结点: (5 个步骤)"></a>在指定的结点后面添加结点: (5 个步骤)</h3><p>指定一个结点的指针, 然后新结点添加在它的后面。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist_insert_middle.png" alt=""></p>
<pre><code>/* 指定一个 prev_node, 然后在它后面添加一个新的结点 */
void insertAfter(struct Node* prev_node, int new_data)
{
    /*1. 判断所给的结点是否为 NULL */
    if (prev_node == NULL) 
    { 
       printf(&quot;the given previous node cannot be NULL&quot;);       
       return;  
    }  

    /* 2. 分配新的结点 */
    struct Node* new_node =(struct Node*) malloc(sizeof(struct Node));

    /* 3. 指定数据  */
    new_node-&gt;data  = new_data;

    /* 4. 新结点的后继指定为 prev_node 的后继*/
    new_node-&gt;next = prev_node-&gt;next; 

    /* 5. 指定 prev_node 后继为新结点 */
    prev_node-&gt;next = new_node;
}
</code></pre><p>这个函数的时间复杂度为 O(1)，因为它做的是连续数量的工作。</p>
<h3 id="在链表尾部添加结点-6-步"><a href="#在链表尾部添加结点-6-步" class="headerlink" title="在链表尾部添加结点: (6 步)"></a>在链表尾部添加结点: (6 步)</h3><p>新结点要求添加在链表的最后。例如，如果给定的链表是<strong>5-&gt;10-&gt;15-&gt;20-&gt;25</strong>然后在最后添加一个<strong>30</strong>, 然后链表就变成了<strong>5-&gt;10-&gt;15-&gt;20-&gt;25-&gt;30</strong>.</p>
<p>因为链表是用头结点表示的, 所以我们必须整个遍历它, 然后修改最后一个结点的后继为新的结点。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist_insert_last.png" alt=""></p>
<pre><code>/* 引用链表的头结点, 指定一个整数, 在尾部添加一个新结点 */
void append(struct Node** head_ref, int new_data)
{
    /* 1. 分配结点 */
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    struct Node *last = *head_ref;  /* used in step 5*/

    /* 2. 指定数据  */
    new_node-&gt;data  = new_data;

    /* 3. 新结点是最后一个结点，所以它的后继为 NULL*/
    new_node-&gt;next = NULL;

    /* 4. 如果链表为空, 那么新结点就是头结点 */
    if (*head_ref == NULL)
    {
       *head_ref = new_node;
       return;
    }  

    /* 5. 遍历到最后一个结点 */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. 修改最后一个结点的后继为新结点 */
    last-&gt;next = new_node;
    return;    
}
</code></pre><p>这个函数的时间复杂度为 O(n) n 是链表的结点数。因为这里有一个循环。</p>
<p>这个函数可以优化到时间复杂度为 O(1)，方法是使用一个尾部指针。</p>
<h3 id="下面是一个完整的程序，使用上面所有的函数创建一个链表"><a href="#下面是一个完整的程序，使用上面所有的函数创建一个链表" class="headerlink" title="下面是一个完整的程序，使用上面所有的函数创建一个链表"></a>下面是一个完整的程序，使用上面所有的函数创建一个链表</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 链表结点
struct Node
{
  int data;
  struct Node *next;
};

/* 指向头结点的指针和一个整数, 在链表前面插入一个新的结点. */
void push(struct Node** head_ref, int new_data)
{
    /* 1. 分配结点 */
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    /* 2. 指定数据  */
    new_node-&gt;data  = new_data;

    /* 3. 新结点的后继作为头部 */
    new_node-&gt;next = (*head_ref);

    /* 4. 头部指向新结点 */
    (*head_ref)    = new_node;
}

/* 指定一个 prev_node, 在给定的结点后面插入一个新结点 */
void insertAfter(struct Node* prev_node, int new_data)
{
    /*1. 判断所给的结点是否为 NULL */
    if (prev_node == NULL)
    {
      printf(&quot;the given previous node cannot be NULL&quot;);
      return;
    }

    /* 2. 分配结点 */
    struct Node* new_node =(struct Node*) malloc(sizeof(struct Node));

    /* 3. 指定数据  */
    new_node-&gt;data  = new_data;

    /* 4. 指定新结点的后继为 prev_node 的后继 */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. 指定 prev_node 后继为新结点 */
    prev_node-&gt;next = new_node;
}

/* 指向头结点的指针和一个整数, 在链表的尾部添加一个新结点  */
void append(struct Node** head_ref, int new_data)
{
    /* 1. 分配结点 */
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    struct Node *last = *head_ref;  /* used in step 5*/

    /* 2. 指定数据  */
    new_node-&gt;data  = new_data;

    /* 3. 新结点会成为最后一个结点, 所以它的后继为 NULL*/
    new_node-&gt;next = NULL;

    /* 4. 如果链表为空, 新结点就是头结点 */
    if (*head_ref == NULL)
    {
       *head_ref = new_node;
       return;
    }

    /* 5. 遍历到最后一个结点 */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. 修改最后一个结点的后继为新结点 */
    last-&gt;next = new_node;
    return;
}

// 这个函数从头打印链表的内容
void printList(struct Node *node)
{
  while (node != NULL)
  {
     printf(&quot; %d &quot;, node-&gt;data);
     node = node-&gt;next;
  }
}

/* 测试函数*/
int main()
{
  /* 空链表开始 */
  struct Node* head = NULL;

  // 插入 6.  链表变成 6-&gt;NULL
  append(&amp;head, 6);

  // 在首部插入 7 . 链表变成 7-&gt;6-&gt;NULL
  push(&amp;head, 7);

  // 在首部插入 1. 链表变成 1-&gt;7-&gt;6-&gt;NULL
  push(&amp;head, 1);

  // 在尾部插入4. 链表变成 1-&gt;7-&gt;6-&gt;4-&gt;NULL
  append(&amp;head, 4);

  // 在 7 后面插入 8, 链表变成 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NULL
  insertAfter(head-&gt;next, 8);

  printf(&quot;\n Created Linked list is: &quot;);
  printList(head);

  return 0;
}

输出:
 Created Linked list is:  1  7  8  6  4
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/链表第1课（链表的介绍）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="跳跳魔王">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跳跳魔王的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/链表第1课（链表的介绍）/" itemprop="url">链表 |第 1 课（链表的介绍）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T13:06:20+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>跟数组类似, 链表也是一个线性的数据结构。跟数组不同的是, 链表的元素并不是相邻的; 而是通过指针联系在一起。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist.png" alt=""></p>
<h3 id="为什么会有链表"><a href="#为什么会有链表" class="headerlink" title="为什么会有链表?"></a>为什么会有链表?</h3><p>数组可以用来存储相似类型的线性数据, 但是数组有以下的限制。</p>
<ol>
<li>数组的大小是固定的: 所以我们必须知道元素数量的上限。同时, 分配的内存对应了上限的使用限制。</li>
<li>在数组中插入一个元素代价非常大, 因为要为新的元素创建空间, 还要移动已存在的元素。</li>
</ol>
<p>例如, 如果有一个排序后的 ID 数组 id[].</p>
<pre><code>id[] = [1000, 1010, 1050, 2000, 2040].
</code></pre><p>如果我们要插入一个新的元素 ID 1005, 然后还要排序, 我们需要移动所有位于 1000 (除了 1000)之后的元素。</p>
<p>对数组进行删除也很麻烦, 除非使用一些特殊技术。例如, 要删除 1010, 位于其后的所有元素都得移动。</p>
<h3 id="相比数组的优点"><a href="#相比数组的优点" class="headerlink" title="相比数组的优点"></a>相比数组的优点</h3><ol>
<li>动态大小</li>
<li>容易插入/删除</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ol>
<li>不允许随机访问。我们必须从第一个结点开始顺序访问元素。所以我们不能对链表进行折半查找。</li>
<li>链表的每个元素都要额外的内存空间。</li>
</ol>
<h3 id="C语言表示法"><a href="#C语言表示法" class="headerlink" title="C语言表示法:"></a>C语言表示法:</h3><p>链表通常用指向头结点的指针表示。如果链表是空的, 头结点就是 <strong>NULL</strong>.</p>
<p>结点通常有两个部分组成:</p>
<ol>
<li>数据</li>
<li>指向下一个结点的指针</li>
</ol>
<p>在 C 语言中, 我们可以用结构图表示一个结点。下面的例子是一个带有整数的结点。</p>
<pre><code>// 链表的结点
struct Node
{
  int data;
  struct Node *next;
};
</code></pre><p>下面，我们来创建一个含有 3 个结点的链表。</p>
<pre><code>// 链表
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct Node 
{
  int data;
  struct Node *next;
};

// 创建含有3个结点的链表
int main()
{
  struct Node* head = NULL;
  struct Node* second = NULL;
  struct Node* third = NULL;

  // 在堆里分配3个结点  
  head = (struct Node*)malloc(sizeof(struct Node)); 
  second = (struct Node*)malloc(sizeof(struct Node));
  third = (struct Node*)malloc(sizeof(struct Node));

  /* 动态分配了3块内存。 
     这3块内存分别是 first, second 喝 third     
       head           second           third
        |                |               |
        |                |               |
    +---+-----+     +----+----+     +----+----+
    | #  | #  |     | #  | #  |     |  # |  # |
    +---+-----+     +----+----+     +----+----+

   # 井号表示随机的值。
   数据是随机的，因为我们还没有制定 */

  head-&gt;data = 1; //指定第一个结点的数据
  head-&gt;next = second; // 把第一个结点和第二个结点连接起来

  /* 现在第一个结点有数据了，它的下一个结点是 second.

       head          second         third
        |              |              |
        |              |              |
    +---+---+     +----+----+     +-----+----+
    | 1  | o-----&gt;| #  | #  |     |  #  | #  |
    +---+---+     +----+----+     +-----+----+    
  */ 

  second-&gt;data = 2; //指定第二个结点的数据
  second-&gt;next = third; // 把第二个结点和第三个结点连接起来

  /* 现在第二个结点有数据了，他的下一个结点是 third.  

       head         second         third
        |             |             |
        |             |             |
    +---+---+     +---+---+     +----+----+
    | 1  | o-----&gt;| 2 | o-----&gt; |  # |  # |
    +---+---+     +---+---+     +----+----+      */   

  third-&gt;data = 3; //指定第三个结点的数据
  third-&gt;next = NULL;

  /* 现在第三个结点也有数据了, 他的后继指针为 NULL 表示链表结束在这里.

           head    
             |
             | 
        +---+---+     +---+---+       +----+------+
        | 1  | o-----&gt;|  2  | o-----&gt; |  3 | NULL |
        +---+---+     +---+---+       +----+------+       


    注意只有头结点可以完整的表示整个链表. */     

  return 0;
}
</code></pre><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><p>在上面的程序里, 我们创建了一个含有3个结点的链表。现在我们来遍历这个链表, 打印每个结点的数据。为了遍历方便, 我们写了一个函数 <strong>printList()</strong>来打印所给的链表。</p>
<blockquote>
<p><strong>我们强烈建议你在查看解决方案前，自己先练习一下。</strong></p>
</blockquote>
<pre><code>// 遍历链表的 C 语言实现
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct Node 
{
  int data;
  struct Node *next;
};

// 打印方法
void printList(struct Node *n)
{
  while (n != NULL)
  {
     printf(&quot; %d &quot;, n-&gt;data);
     n = n-&gt;next;
  }
}

int main()
{
  struct Node* head = NULL;
  struct Node* second = NULL;
  struct Node* third = NULL;

  // 在堆中分配3个结点  
  head  = (struct Node*)malloc(sizeof(struct Node)); 
  second = (struct Node*)malloc(sizeof(struct Node));
  third  = (struct Node*)malloc(sizeof(struct Node));

  head-&gt;data = 1; //指定第一个结点的数据
  head-&gt;next = second; // 连接到第二个结点   

  second-&gt;data = 2; //指定第二个结点的数据
  second-&gt;next = third;  

  third-&gt;data = 3; //指定第三个结点的数据
  third-&gt;next = NULL;

  printList(head);

  return 0;
}

Output:
 1  2  3
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">跳跳魔王</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">跳跳魔王</span>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
