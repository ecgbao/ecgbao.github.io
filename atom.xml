<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>跳跳魔王的技术博客</title>
  
  <subtitle>科技改变生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-09T08:14:51.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>跳跳魔王</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表 | 第5课（查找元素）</title>
    <link href="http://yoursite.com/2018/03/09/%E9%93%BE%E8%A1%A8%E7%AC%AC5%E8%AF%BE%EF%BC%88%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/09/链表第5课（查找元素）/</id>
    <published>2018-03-09T07:48:16.000Z</published>
    <updated>2018-03-09T08:14:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>写一个 C 函数，在指定的单链表中查找一个指定的 key ‘x’. 如果 x 存在返回 true 否则返回 false.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   bool search(Node *head, int x) </span><br><span class="line">```  </span><br><span class="line">   </span><br><span class="line">例如, 如果 key 是 15 ，链表是 14-&gt;21-&gt;11-&gt;30-&gt;10, 那么函数会返回 false. 如果 key 是 14, 函数就返回 true.</span><br><span class="line"></span><br><span class="line">### 迭代方案</span><br></pre></td></tr></table></figure><p>2) 初始一个结点指针, current = head.<br>3) 如果 current 不为 NULL 就继续循环<br>    a) current-&gt;key 等于要搜索的 key 返回 true.<br>    b) current = current-&gt;next<br>4) 返回 false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是迭代方案的算法。</span><br></pre></td></tr></table></figure></p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;stdlib.h&gt;</p><p>#include&lt;stdbool.h</p><p>/<em> 链表结点 </em>/<br>struct Node<br>{<br>    int key;<br>    struct Node* next;<br>};</p><p>/<em> 指向头结点的指针和一个整数, 在链表头部加入一个新结点. </em>/<br>void push(struct Node*<em> head_ref, int new_key)<br>{<br>    /</em> 分配结点 <em>/<br>    struct Node</em> new_node =<br>            (struct Node*) malloc(sizeof(struct Node));</p><pre><code>/* 指定 key  */new_node-&gt;key  = new_key;/* 把新结点连接到老链表 */new_node-&gt;next = (*head_ref);/* 新结点变成头结点 */(*head_ref)    = new_node;</code></pre><p>}</p><p>/<em> 判断 x 是否在链表里 </em>/<br>bool search(struct Node<em> head, int x)<br>{<br>    struct Node</em> current = head;  // 初始 current<br>    while (current != NULL)<br>    {<br>        if (current-&gt;key == x)<br>            return true;<br>        current = current-&gt;next;<br>    }<br>    return false;<br>}</p><p>/<em> 测试程序</em>/<br>int main()<br>{<br>    /<em> Start with the empty list </em>/<br>    struct Node* head = NULL;<br>    int x = 21;</p><pre><code>/* Use push() to construct below list 14-&gt;21-&gt;11-&gt;30-&gt;10  */push(&amp;head, 10);push(&amp;head, 30);push(&amp;head, 11);push(&amp;head, 21);push(&amp;head, 14);search(head, 21)? printf(&quot;Yes&quot;) : printf(&quot;No&quot;);return 0;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">输出:</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure></p><h3 id="递归方案"><a href="#递归方案" class="headerlink" title="递归方案"></a>递归方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool search(head, x)</span><br><span class="line">1) 如果头结点为 NULL, 返回 false.</span><br><span class="line">2) 如果头结点的 key 等于 x, 返回 true;</span><br><span class="line">2) 否则返回 search(head-&gt;next, x)</span><br></pre></td></tr></table></figure><p>下面是递归算法的实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">/* Link list node */</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int key;</span><br><span class="line">    struct Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 指向头结点的指针和一个整数, 在链表头部加入一个新结点. */</span><br><span class="line">void push(struct Node** head_ref, int new_key)</span><br><span class="line">&#123;</span><br><span class="line">    /* 分配结点 */</span><br><span class="line">    struct Node* new_node =</span><br><span class="line">            (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">    /* 指定 key  */</span><br><span class="line">    new_node-&gt;key  = new_key;</span><br><span class="line"> </span><br><span class="line">    /* 把新结点连接到老链表 */</span><br><span class="line">    new_node-&gt;next = (*head_ref);</span><br><span class="line"> </span><br><span class="line">    /* 新结点变成头结点 */</span><br><span class="line">    (*head_ref)    = new_node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 判断 x 是否在链表里 */</span><br><span class="line">bool search(struct Node* head, int x)</span><br><span class="line">&#123;</span><br><span class="line">    // 递归结束条件</span><br><span class="line">    if (head == NULL)</span><br><span class="line">        return false;</span><br><span class="line">     </span><br><span class="line">    // 如果 key 在头结点, 返回 true</span><br><span class="line">    if (head-&gt;key == x)</span><br><span class="line">        return true;</span><br><span class="line"> </span><br><span class="line">    // 递归剩下的列表</span><br><span class="line">    return search(head-&gt;next, x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 测试程序*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 开始空链表 */</span><br><span class="line">    struct Node* head = NULL;</span><br><span class="line">    int x = 21;</span><br><span class="line"> </span><br><span class="line">    /* 使用 push() 构造链表</span><br><span class="line">     14-&gt;21-&gt;11-&gt;30-&gt;10  */</span><br><span class="line">    push(&amp;head, 10);</span><br><span class="line">    push(&amp;head, 30);</span><br><span class="line">    push(&amp;head, 11);</span><br><span class="line">    push(&amp;head, 21);</span><br><span class="line">    push(&amp;head, 14);</span><br><span class="line"> </span><br><span class="line">    search(head, 21)? printf(&quot;Yes&quot;) : printf(&quot;No&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写一个 C 函数，在指定的单链表中查找一个指定的 key ‘x’. 如果 x 存在返回 true 否则返回 false.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表 | 第4课（链表的长度）</title>
    <link href="http://yoursite.com/2018/03/09/%E9%93%BE%E8%A1%A8%E7%AC%AC4%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/09/链表第4课（链表的长度）/</id>
    <published>2018-03-09T07:06:33.000Z</published>
    <updated>2018-03-09T07:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>要求写一个 C 函数计算指定单链表的结点数。</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2015/03/Linkedlist_find_length.png" alt=""></p><p>例如, 链表<strong>1-&gt;3-&gt;1-&gt;2-&gt;1</strong>通过这个函数可以获取到 5 个结点。</p><h3 id="迭代方案"><a href="#迭代方案" class="headerlink" title="迭代方案"></a>迭代方案</h3><ol><li>初始化计数为 0 </li><li>初始化一个结点指针, <strong>current = head</strong>.</li><li><p>如果 current 不为 NULL 继续循环</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a) current = current -&gt; next</span><br><span class="line">b) count++;</span><br></pre></td></tr></table></figure></li></ol><ol><li>返回计数 </li></ol><p>下面是 C/C++ 实现的计数算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">/* Link list node */</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 指向头结点的指针和一个整数, 在链表的头部添加一个新结点. */</span><br><span class="line">void push(struct Node** head_ref, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /* allocate node */</span><br><span class="line">    struct Node* new_node =</span><br><span class="line">            (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">    /* put in the data  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line"> </span><br><span class="line">    /* link the old list off the new node */</span><br><span class="line">    new_node-&gt;next = (*head_ref);</span><br><span class="line"> </span><br><span class="line">    /* move the head to point to the new node */</span><br><span class="line">    (*head_ref)    = new_node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 获取链表的结点数 */</span><br><span class="line">int getCount(struct Node* head)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;  // 初始值</span><br><span class="line">    struct Node* current = head;  // 当前结点</span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 测试函数*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 开始空链表 */</span><br><span class="line">    struct Node* head = NULL;</span><br><span class="line"> </span><br><span class="line">    /* 使用 push() 构造链表</span><br><span class="line">     1-&gt;2-&gt;1-&gt;3-&gt;1  */</span><br><span class="line">    push(&amp;head, 1);</span><br><span class="line">    push(&amp;head, 3);</span><br><span class="line">    push(&amp;head, 1);</span><br><span class="line">    push(&amp;head, 2);</span><br><span class="line">    push(&amp;head, 1);</span><br><span class="line"> </span><br><span class="line">    /* 计数函数 */</span><br><span class="line">    printf(&quot;count of nodes is %d&quot;, getCount(head));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">count of nodes is 5</span><br></pre></td></tr></table></figure><h3 id="递归方案"><a href="#递归方案" class="headerlink" title="递归方案"></a>递归方案</h3><h5 id="int-getCount-head"><a href="#int-getCount-head" class="headerlink" title="int getCount(head)"></a>int getCount(head)</h5><ol><li>如果头结点为 NULL, 返回 0.</li><li>否则返回 <figure class="highlight plain"><figcaption><span>1 + getCount(head->next) ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是 C/C++ 实现的递归算法。</span><br></pre></td></tr></table></figure></li></ol><p>#include&lt;stdio.h&gt;</p><p>#include&lt;stdlib.h&gt;</p><p>/<em> 链表结点 </em>/<br>struct Node<br>{<br>    int data;<br>    struct Node* next;<br>};</p><p>/<em> 指向头结点的指针和一个整数, 在链表的头部添加一个新结点 </em>/<br>void push(struct Node*<em> head_ref, int new_data)<br>{<br>    /</em> 分配结点 <em>/<br>    struct Node</em> new_node =<br>            (struct Node*) malloc(sizeof(struct Node));</p><pre><code>/* 指定数据  */new_node-&gt;data  = new_data;/* 指定新结点的后继为旧的头结点 */new_node-&gt;next = (*head_ref);/* 新结点成为头结点 */(*head_ref)    = new_node;</code></pre><p>}</p><p>/<em> 计数函数</em>/<br>int getCount(struct Node* head)<br>{<br>    // 递归结束条件<br>    if (head == NULL)<br>        return 0;</p><pre><code>return 1 + getCount(head-&gt;next);</code></pre><p>}</p><p>/<em> 测试函数</em>/<br>int main()<br>{<br>    /<em> 开始空链表 </em>/<br>    struct Node* head = NULL;</p><pre><code>/* 使用 push() 构造链表 1-&gt;2-&gt;1-&gt;3-&gt;1  */push(&amp;head, 1);push(&amp;head, 3);push(&amp;head, 1);push(&amp;head, 2);push(&amp;head, 1);/* 计数函数 */printf(&quot;count of nodes is %d&quot;, getCount(head));return 0;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">输出:</span><br><span class="line">count of nodes is 5</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要求写一个 C 函数计算指定单链表的结点数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.geeksforgeeks.org/wp-content/uploads/gq/2015/03/Linkedlist_find_length.png&quot; alt=&quot;&quot;&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表| 第2课（链表的插入）</title>
    <link href="http://yoursite.com/2018/03/09/%E9%93%BE%E8%A1%A8%E7%AC%AC2%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/09/链表第2课（链表的插入）/</id>
    <published>2018-03-09T05:58:06.000Z</published>
    <updated>2018-03-09T06:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在先前的文章里，我们已经简单介绍了<a href="https://ecgbao.github.io/2018/03/09/%E9%93%BE%E8%A1%A8-%E7%AC%AC-1-%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89/" target="_blank" rel="noopener">链表</a>。我们也创建了一个带有3个结点的简单链表，然后讨论了一下如何遍历它们。</p><p><strong><em>这篇文章涉及到的所有程序均使用下面的结点表示链表。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 链表结点</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这篇文章里, 会讨论如何在链表里插入结点。一般来说，有3个方法来添加结点。</p><ol><li>在链表的首部。</li><li>在一个给定的结点之后。</li><li>在链表的尾部。</li></ol><h3 id="在首部添加一个结点-4步"><a href="#在首部添加一个结点-4步" class="headerlink" title="在首部添加一个结点: (4步)"></a>在首部添加一个结点: (4步)</h3><p>新结点要添加在给定链表的首部。新添加的结点成为新的头结点。例如, 如果给定的链表是<strong>10-&gt;15-&gt;20-&gt;25</strong> 我们要再首部添加一个<strong>5</strong>, 然后链表就会变成<strong>5-&gt;10-&gt;15-&gt;20-&gt;25</strong>. 我们使用一个函数<strong>push()</strong>来表示。 这个函数必须接收一个指向头指针的指针, 因为需要修改它指向新加的结点。</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist_insert_at_start.png" alt=""></p><p>下面是在首部添加结点的4个步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 引用链表的头结点，指定一个整数, 然后在链表首部添加一个新的结点。*/</span><br><span class="line">void push(struct Node** head_ref, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /* 1. 分配结点 */</span><br><span class="line">    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line">  </span><br><span class="line">    /* 2. 指定数据  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line">  </span><br><span class="line">    /* 3. 指定新结点的后继为 head_ref */</span><br><span class="line">    new_node-&gt;next = (*head_ref);</span><br><span class="line">  </span><br><span class="line">    /* 4. 头部指向新结点 */</span><br><span class="line">    (*head_ref)    = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度为 O(1)，因为它做的是连续数量的工作。</p><h3 id="在指定的结点后面添加结点-5-个步骤"><a href="#在指定的结点后面添加结点-5-个步骤" class="headerlink" title="在指定的结点后面添加结点: (5 个步骤)"></a>在指定的结点后面添加结点: (5 个步骤)</h3><p>指定一个结点的指针, 然后新结点添加在它的后面。</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist_insert_middle.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 指定一个 prev_node, 然后在它后面添加一个新的结点 */</span><br><span class="line">void insertAfter(struct Node* prev_node, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /*1. 判断所给的结点是否为 NULL */</span><br><span class="line">    if (prev_node == NULL) </span><br><span class="line">    &#123; </span><br><span class="line">       printf(&quot;the given previous node cannot be NULL&quot;);       </span><br><span class="line">       return;  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">    /* 2. 分配新的结点 */</span><br><span class="line">    struct Node* new_node =(struct Node*) malloc(sizeof(struct Node));</span><br><span class="line">  </span><br><span class="line">    /* 3. 指定数据  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line">  </span><br><span class="line">    /* 4. 新结点的后继指定为 prev_node 的后继*/</span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next; </span><br><span class="line">  </span><br><span class="line">    /* 5. 指定 prev_node 后继为新结点 */</span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度为 O(1)，因为它做的是连续数量的工作。</p><h3 id="在链表尾部添加结点-6-步"><a href="#在链表尾部添加结点-6-步" class="headerlink" title="在链表尾部添加结点: (6 步)"></a>在链表尾部添加结点: (6 步)</h3><p>新结点要求添加在链表的最后。例如，如果给定的链表是<strong>5-&gt;10-&gt;15-&gt;20-&gt;25</strong>然后在最后添加一个<strong>30</strong>, 然后链表就变成了<strong>5-&gt;10-&gt;15-&gt;20-&gt;25-&gt;30</strong>.</p><p>因为链表是用头结点表示的, 所以我们必须整个遍历它, 然后修改最后一个结点的后继为新的结点。</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist_insert_last.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 引用链表的头结点, 指定一个整数, 在尾部添加一个新结点 */</span><br><span class="line">void append(struct Node** head_ref, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /* 1. 分配结点 */</span><br><span class="line">    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">    struct Node *last = *head_ref;  /* used in step 5*/</span><br><span class="line">  </span><br><span class="line">    /* 2. 指定数据  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line"> </span><br><span class="line">    /* 3. 新结点是最后一个结点，所以它的后继为 NULL*/</span><br><span class="line">    new_node-&gt;next = NULL;</span><br><span class="line"> </span><br><span class="line">    /* 4. 如果链表为空, 那么新结点就是头结点 */</span><br><span class="line">    if (*head_ref == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">       *head_ref = new_node;</span><br><span class="line">       return;</span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /* 5. 遍历到最后一个结点 */</span><br><span class="line">    while (last-&gt;next != NULL)</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">  </span><br><span class="line">    /* 6. 修改最后一个结点的后继为新结点 */</span><br><span class="line">    last-&gt;next = new_node;</span><br><span class="line">    return;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度为 O(n) n 是链表的结点数。因为这里有一个循环。</p><p>这个函数可以优化到时间复杂度为 O(1)，方法是使用一个尾部指针。</p><h3 id="下面是一个完整的程序，使用上面所有的函数创建一个链表"><a href="#下面是一个完整的程序，使用上面所有的函数创建一个链表" class="headerlink" title="下面是一个完整的程序，使用上面所有的函数创建一个链表"></a>下面是一个完整的程序，使用上面所有的函数创建一个链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">// 链表结点</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 指向头结点的指针和一个整数, 在链表前面插入一个新的结点. */</span><br><span class="line">void push(struct Node** head_ref, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /* 1. 分配结点 */</span><br><span class="line">    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">    /* 2. 指定数据  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line"> </span><br><span class="line">    /* 3. 新结点的后继作为头部 */</span><br><span class="line">    new_node-&gt;next = (*head_ref);</span><br><span class="line"> </span><br><span class="line">    /* 4. 头部指向新结点 */</span><br><span class="line">    (*head_ref)    = new_node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 指定一个 prev_node, 在给定的结点后面插入一个新结点 */</span><br><span class="line">void insertAfter(struct Node* prev_node, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /*1. 判断所给的结点是否为 NULL */</span><br><span class="line">    if (prev_node == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;the given previous node cannot be NULL&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 2. 分配结点 */</span><br><span class="line">    struct Node* new_node =(struct Node*) malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">    /* 3. 指定数据  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line"> </span><br><span class="line">    /* 4. 指定新结点的后继为 prev_node 的后继 */</span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line"> </span><br><span class="line">    /* 5. 指定 prev_node 后继为新结点 */</span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 指向头结点的指针和一个整数, 在链表的尾部添加一个新结点  */</span><br><span class="line">void append(struct Node** head_ref, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    /* 1. 分配结点 */</span><br><span class="line">    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">    struct Node *last = *head_ref;  /* used in step 5*/</span><br><span class="line"> </span><br><span class="line">    /* 2. 指定数据  */</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line"> </span><br><span class="line">    /* 3. 新结点会成为最后一个结点, 所以它的后继为 NULL*/</span><br><span class="line">    new_node-&gt;next = NULL;</span><br><span class="line"> </span><br><span class="line">    /* 4. 如果链表为空, 新结点就是头结点 */</span><br><span class="line">    if (*head_ref == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">       *head_ref = new_node;</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 5. 遍历到最后一个结点 */</span><br><span class="line">    while (last-&gt;next != NULL)</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line"> </span><br><span class="line">    /* 6. 修改最后一个结点的后继为新结点 */</span><br><span class="line">    last-&gt;next = new_node;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 这个函数从头打印链表的内容</span><br><span class="line">void printList(struct Node *node)</span><br><span class="line">&#123;</span><br><span class="line">  while (node != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">     printf(&quot; %d &quot;, node-&gt;data);</span><br><span class="line">     node = node-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 测试函数*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  /* 空链表开始 */</span><br><span class="line">  struct Node* head = NULL;</span><br><span class="line"> </span><br><span class="line">  // 插入 6.  链表变成 6-&gt;NULL</span><br><span class="line">  append(&amp;head, 6);</span><br><span class="line"> </span><br><span class="line">  // 在首部插入 7 . 链表变成 7-&gt;6-&gt;NULL</span><br><span class="line">  push(&amp;head, 7);</span><br><span class="line"> </span><br><span class="line">  // 在首部插入 1. 链表变成 1-&gt;7-&gt;6-&gt;NULL</span><br><span class="line">  push(&amp;head, 1);</span><br><span class="line"> </span><br><span class="line">  // 在尾部插入4. 链表变成 1-&gt;7-&gt;6-&gt;4-&gt;NULL</span><br><span class="line">  append(&amp;head, 4);</span><br><span class="line"> </span><br><span class="line">  // 在 7 后面插入 8, 链表变成 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NULL</span><br><span class="line">  insertAfter(head-&gt;next, 8);</span><br><span class="line"> </span><br><span class="line">  printf(&quot;\n Created Linked list is: &quot;);</span><br><span class="line">  printList(head);</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line"> Created Linked list is:  1  7  8  6  4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在先前的文章里，我们已经简单介绍了&lt;a href=&quot;https://ecgbao.github.io/2018/03/09/%E9%93%BE%E8%A1%A8-%E7%AC%AC-1-%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%8
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表 |第 1 课（链表的介绍）</title>
    <link href="http://yoursite.com/2018/03/09/%E9%93%BE%E8%A1%A8%E7%AC%AC1%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/09/链表第1课（链表的介绍）/</id>
    <published>2018-03-09T05:06:20.000Z</published>
    <updated>2018-03-09T05:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟数组类似, 链表也是一个线性的数据结构。跟数组不同的是, 链表的元素并不是相邻的; 而是通过指针联系在一起。</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Linkedlist.png" alt=""></p><h3 id="为什么会有链表"><a href="#为什么会有链表" class="headerlink" title="为什么会有链表?"></a>为什么会有链表?</h3><p>数组可以用来存储相似类型的线性数据, 但是数组有以下的限制。</p><ol><li>数组的大小是固定的: 所以我们必须知道元素数量的上限。同时, 分配的内存对应了上限的使用限制。</li><li>在数组中插入一个元素代价非常大, 因为要为新的元素创建空间, 还要移动已存在的元素。</li></ol><p>例如, 如果有一个排序后的 ID 数组 id[].</p><pre><code>id[] = [1000, 1010, 1050, 2000, 2040].</code></pre><p>如果我们要插入一个新的元素 ID 1005, 然后还要排序, 我们需要移动所有位于 1000 (除了 1000)之后的元素。</p><p>对数组进行删除也很麻烦, 除非使用一些特殊技术。例如, 要删除 1010, 位于其后的所有元素都得移动。</p><h3 id="相比数组的优点"><a href="#相比数组的优点" class="headerlink" title="相比数组的优点"></a>相比数组的优点</h3><ol><li>动态大小</li><li>容易插入/删除</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ol><li>不允许随机访问。我们必须从第一个结点开始顺序访问元素。所以我们不能对链表进行折半查找。</li><li>链表的每个元素都要额外的内存空间。</li></ol><h3 id="C语言表示法"><a href="#C语言表示法" class="headerlink" title="C语言表示法:"></a>C语言表示法:</h3><p>链表通常用指向头结点的指针表示。如果链表是空的, 头结点就是 <strong>NULL</strong>.</p><p>结点通常有两个部分组成:</p><ol><li>数据</li><li>指向下一个结点的指针</li></ol><p>在 C 语言中, 我们可以用结构图表示一个结点。下面的例子是一个带有整数的结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 链表的结点</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面，我们来创建一个含有 3 个结点的链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 链表</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Node </span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 创建含有3个结点的链表</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  struct Node* head = NULL;</span><br><span class="line">  struct Node* second = NULL;</span><br><span class="line">  struct Node* third = NULL;</span><br><span class="line">   </span><br><span class="line">  // 在堆里分配3个结点  </span><br><span class="line">  head = (struct Node*)malloc(sizeof(struct Node)); </span><br><span class="line">  second = (struct Node*)malloc(sizeof(struct Node));</span><br><span class="line">  third = (struct Node*)malloc(sizeof(struct Node));</span><br><span class="line"> </span><br><span class="line">  /* 动态分配了3块内存。 </span><br><span class="line">     这3块内存分别是 first, second 喝 third     </span><br><span class="line">       head           second           third</span><br><span class="line">        |                |               |</span><br><span class="line">        |                |               |</span><br><span class="line">    +---+-----+     +----+----+     +----+----+</span><br><span class="line">    | #  | #  |     | #  | #  |     |  # |  # |</span><br><span class="line">    +---+-----+     +----+----+     +----+----+</span><br><span class="line">    </span><br><span class="line">   # 井号表示随机的值。</span><br><span class="line">   数据是随机的，因为我们还没有制定 */</span><br><span class="line">   </span><br><span class="line">  head-&gt;data = 1; //指定第一个结点的数据</span><br><span class="line">  head-&gt;next = second; // 把第一个结点和第二个结点连接起来</span><br><span class="line">   </span><br><span class="line">  /* 现在第一个结点有数据了，它的下一个结点是 second.</span><br><span class="line"> </span><br><span class="line">       head          second         third</span><br><span class="line">        |              |              |</span><br><span class="line">        |              |              |</span><br><span class="line">    +---+---+     +----+----+     +-----+----+</span><br><span class="line">    | 1  | o-----&gt;| #  | #  |     |  #  | #  |</span><br><span class="line">    +---+---+     +----+----+     +-----+----+    </span><br><span class="line">  */ </span><br><span class="line">   </span><br><span class="line">  second-&gt;data = 2; //指定第二个结点的数据</span><br><span class="line">  second-&gt;next = third; // 把第二个结点和第三个结点连接起来</span><br><span class="line">   </span><br><span class="line">  /* 现在第二个结点有数据了，他的下一个结点是 third.  </span><br><span class="line">   </span><br><span class="line">       head         second         third</span><br><span class="line">        |             |             |</span><br><span class="line">        |             |             |</span><br><span class="line">    +---+---+     +---+---+     +----+----+</span><br><span class="line">    | 1  | o-----&gt;| 2 | o-----&gt; |  # |  # |</span><br><span class="line">    +---+---+     +---+---+     +----+----+      */   </span><br><span class="line">   </span><br><span class="line">  third-&gt;data = 3; //指定第三个结点的数据</span><br><span class="line">  third-&gt;next = NULL;</span><br><span class="line">   </span><br><span class="line">  /* 现在第三个结点也有数据了, 他的后继指针为 NULL 表示链表结束在这里.</span><br><span class="line"> </span><br><span class="line">           head    </span><br><span class="line">             |</span><br><span class="line">             | </span><br><span class="line">        +---+---+     +---+---+       +----+------+</span><br><span class="line">        | 1  | o-----&gt;|  2  | o-----&gt; |  3 | NULL |</span><br><span class="line">        +---+---+     +---+---+       +----+------+       </span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    注意只有头结点可以完整的表示整个链表. */     </span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><p>在上面的程序里, 我们创建了一个含有3个结点的链表。现在我们来遍历这个链表, 打印每个结点的数据。为了遍历方便, 我们写了一个函数 <strong>printList()</strong>来打印所给的链表。</p><blockquote><p><strong>我们强烈建议你在查看解决方案前，自己先练习一下。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 遍历链表的 C 语言实现</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Node </span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 打印方法</span><br><span class="line">void printList(struct Node *n)</span><br><span class="line">&#123;</span><br><span class="line">  while (n != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">     printf(&quot; %d &quot;, n-&gt;data);</span><br><span class="line">     n = n-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  struct Node* head = NULL;</span><br><span class="line">  struct Node* second = NULL;</span><br><span class="line">  struct Node* third = NULL;</span><br><span class="line">   </span><br><span class="line">  // 在堆中分配3个结点  </span><br><span class="line">  head  = (struct Node*)malloc(sizeof(struct Node)); </span><br><span class="line">  second = (struct Node*)malloc(sizeof(struct Node));</span><br><span class="line">  third  = (struct Node*)malloc(sizeof(struct Node));</span><br><span class="line">  </span><br><span class="line">  head-&gt;data = 1; //指定第一个结点的数据</span><br><span class="line">  head-&gt;next = second; // 连接到第二个结点   </span><br><span class="line">  </span><br><span class="line">  second-&gt;data = 2; //指定第二个结点的数据</span><br><span class="line">  second-&gt;next = third;  </span><br><span class="line">  </span><br><span class="line">  third-&gt;data = 3; //指定第三个结点的数据</span><br><span class="line">  third-&gt;next = NULL;</span><br><span class="line">   </span><br><span class="line">  printList(head);</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>Output: 1  2  3</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跟数组类似, 链表也是一个线性的数据结构。跟数组不同的是, 链表的元素并不是相邻的; 而是通过指针联系在一起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.geeksforgeeks.org/wp-content/uploads/gq/2013/03/Link
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表 |第 3 课（删除一个结点）</title>
    <link href="http://yoursite.com/2018/03/09/%E9%93%BE%E8%A1%A8%E7%AC%AC3%E8%AF%BE%20(%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9)/"/>
    <id>http://yoursite.com/2018/03/09/链表第3课 (删除一个结点)/</id>
    <published>2018-03-09T01:02:05.000Z</published>
    <updated>2018-03-09T06:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在单链表章节我们已经讨论了 <a href="https://ecgbao.github.io/2018/03/09/%E9%93%BE%E8%A1%A8-%E7%AC%AC-1-%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89/" target="_blank" rel="noopener">链表的介绍</a> 和 <a href="https://ecgbao.github.io/2018/03/09/%E9%93%BE%E8%A1%A8%20%7C%20%E7%AC%AC2%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%89/" target="_blank" rel="noopener">链表的插入</a>。</p><p>我们阐述一下问题描述，帮助理解删除的过程。给定一个 ‘key’, 删除链表里第一个出现的结点。<br>要从链表里删除一个结点, 我们需要以下步骤。</p><ol><li>找到待删结点的前驱结点。</li><li>修改前驱结点的Next.</li><li>释放被删除结点的内存。</li></ol><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/05/Linkedlist_deletion.png" alt=""></p><blockquote><p><strong><em>建议:</em></strong> 在查看解决方案前，请自己尝试练习。</p></blockquote><p>因为链表的每个结点都是通过 malloc() 动态分配的, 所以我们需要释放被删除结点的内存。</p><h3 id="下面是C-C-代码"><a href="#下面是C-C-代码" class="headerlink" title="下面是C/C++代码"></a>下面是C/C++代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码已经通过编译</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">// 结点定义</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 引用链表的头结点和一个整数值, 在链表前面插入一个新的结点 */</span><br><span class="line">void push(struct Node** head_ref, int new_data)</span><br><span class="line">&#123;</span><br><span class="line">    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));</span><br><span class="line">    new_node-&gt;data  = new_data;</span><br><span class="line">    new_node-&gt;next = (*head_ref);</span><br><span class="line">    (*head_ref)    = new_node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 引用链表的头结点和一个 key, 然后删除首次遇见的结点 */</span><br><span class="line">void deleteNode(struct Node **head_ref, int key)</span><br><span class="line">&#123;</span><br><span class="line">    // 保存头结点</span><br><span class="line">    struct Node* temp = *head_ref, *prev;</span><br><span class="line"> </span><br><span class="line">    // 如果要删除的结点恰巧是头结点</span><br><span class="line">    if (temp != NULL &amp;&amp; temp-&gt;data == key)</span><br><span class="line">    &#123;</span><br><span class="line">        *head_ref = temp-&gt;next;   // 修改头结点</span><br><span class="line">        free(temp);               // 释放头结点</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 查找要删除的 key, 因为我们要修改&apos;prev-&gt;next&apos;，所以需要跟踪前驱结点</span><br><span class="line">    while (temp != NULL &amp;&amp; temp-&gt;data != key)</span><br><span class="line">    &#123;</span><br><span class="line">        prev = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 如果链表里没有这个 key</span><br><span class="line">    if (temp == NULL) return;</span><br><span class="line"> </span><br><span class="line">    // 断开结点</span><br><span class="line">    prev-&gt;next = temp-&gt;next;</span><br><span class="line"> </span><br><span class="line">    free(temp);  // 释放内存</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下面的函数打印链表的内容</span><br><span class="line">void printList(struct Node *node)</span><br><span class="line">&#123;</span><br><span class="line">    while (node != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot; %d &quot;, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 测试函数*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 刚开始的空链表 */</span><br><span class="line">    struct Node* head = NULL;</span><br><span class="line"> </span><br><span class="line">    push(&amp;head, 7);</span><br><span class="line">    push(&amp;head, 1);</span><br><span class="line">    push(&amp;head, 3);</span><br><span class="line">    push(&amp;head, 2);</span><br><span class="line"> </span><br><span class="line">    puts(&quot;Created Linked List: &quot;);</span><br><span class="line">    printList(head);</span><br><span class="line">    deleteNode(&amp;head, 1);</span><br><span class="line">    puts(&quot;\nLinked List after Deletion of 1: &quot;);</span><br><span class="line">    printList(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Created Linked List:</span><br><span class="line"> 2  3  1  7</span><br><span class="line">Linked List after Deletion of 1:</span><br><span class="line"> 2  3  7</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在单链表章节我们已经讨论了 &lt;a href=&quot;https://ecgbao.github.io/2018/03/09/%E9%93%BE%E8%A1%A8-%E7%AC%AC-1-%E8%AF%BE%EF%BC%88%E9%93%BE%E8%A1%A8%E7%9A%84%E
      
    
    </summary>
    
    
  </entry>
  
</feed>
